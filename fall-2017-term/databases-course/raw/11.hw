# Лекция 11

Разминка. Есть отношение R(num, ...). T(R) = 10000 -- количество строчек в таблице, B(R) = 100 -- количество дисковых блоков. Построено B-дерево Index (num)
TODO : картинка
Выполнен запрос: SELECT \* FROM R WHERE num $>$ 7000.
Кол-во I/O? Хочешь посчитать какое-то конкретное число или хотя бы указать диапазон.

Ответ. от 30 до 100. Разберемся в этом подробнее.

Какие есть возможности по использованию индексов?
Индексы бывают кластеризующие и некластеризующие.
Кластеризующий -- такой, для которого выполняется свойство проиндексированного атрибута, т.е. это строки таблицы с одинаковым значением проиндексированного атрибута
Упакованы плотно, занимают минимально возможное количество блоков.
Если строки разбросаны по всей таблице, то индекс некластеризующий
В первом случае мы можем быстро считать нужные индексы.
Кластеризующий индекс по сути определяет как данные хранятся в таблице(спускаемся к грешной земле)

Но зачем тогда нужен некластеризующий?
Сколько кластеризующих индексов можем построить, если у атрибутов вообще нет зависимостей друг от друга? Один. 

Оценки стоимости поиска по индексу.
T(R) -- количество записей/строк в таблице
B(R) -- количество блоков
Рассмотрим какой-нибудь атрибут. Обозначим его за а.
V(R, a) -- кардинальность атрибута а. Кардинальность -- число различных значений этого атрибута.
Для кардинальности имеем тривиальное неравенство: $1 <= V(R, a) <= $количество записей 
Если a -- это ключ, то верхняя оценка достигается.
Фигачим запрос по условию: $\sigma_{a = c} = c(R)$ есть индекс R.a
Сколько строк выберем, при условии, если значения распределенны равномерно? 
если значения а равномерно распределены, то тогда размер выборки $@T(R)/V(R, a)@$
количество I/O для чтения блоков?
Если индекс кластеризующий, то тогда  $@B(R)/V(R, a)@$ I/O
Если индекс некластеризующий, то тогда $@T(R)/V(R, a)@$ I/O в "тупом" случае.

Но БД для начала строит map -- Bitmap Index Scan, размера количества страниц.
где на i от бите хранится флажок: нужно ли доставать i-ю страницу или нет.
В запросе есть несколько условий на равенство атрибутов, то несколько bitmap и их побитовое И(быстрое), даст нужные страницы, которые нужно выдать для запроса, именно поэтому нужен bitmap.

С неравенством немного сложнее. 
Гистограммы. Сколько значений хранится для каждого индекса.

## Index Join

$R(X, Y) \bowtie S(Y, Z)$
для S, Y есть индекс

наивный алгоритм:
читай все строки из R 
	для каждой записи $r \in R$
		найди s: $\{s\}_Y = \{r\}_Y$
			используя индекс

все строки из R:
	B(R)
	для r соединящихся строк $@T(S)/V(S, Y)@$
	для r соединящихся блоков $@B(S)/V(S, Y)@$

Количество I/O: $B(R) + T(R) * @B(S)/V(S, Y)@$
В примерах, которые были раньше
B(R) = 1000
B(S) = 500
T(R) = 10000
T(S) = 5000
V(S, Y) = 500

Итого: 1000 + 10000 = 11000, что кажется это слишком много.

## Варианты улучшения

1-ый проход. B(R) чтений и bitmap по индексу S.r
2-й проход: вложенные циклы
с R -- внешнее отношение
блоки из S: бит в битмап = 1
	внутреннее отношение

Если есть индекс для R.Y
Нужны сами записи из R и S?
Если да, то битмапы, все такое
Если нет, то Index Only Join/Scan

"Буфера памяти"

## Итеративная модель вычислений

$R \bowtie \sigma_{a = c}(S)$
TODO картинка

\begin{lstlisting}
Iterator \{
	Open(); // размещение структур в памяти. Подготовка к возвращению первой строки результата
	GetNext() Record; // возвращает текущую строку, переходит к следующей
	Close(); // закрывает, убирает все из памяти
\}
\end{lstlisting}

HashJoin(Iterator left, Iterator right) implements Iterator {}

Физический план выполнения запроса

\begin{lstlisting}
HashJoin =>  
	Hash =>  
		SeqScan
	IndexScan(S) по условию a = c
\end{lstlisting}