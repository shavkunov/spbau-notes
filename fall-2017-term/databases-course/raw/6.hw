# Лекция 6

## Физическое выполнение запросов

Во время работы БД данные записываются в разные типы памяти. Поговорим про эти типы.

\begin{tabularx}{\textwidth}{c | c | c | c | c}
Тип памяти & Объем & скорость доступа & энергозависимость & цена/Gb
Cache процессоры & XX Mb & 1ns & зависит & \$\$\$
RAM & XXX Gb & 100ns & зависит & \$\$
HDD & X Tb & 1-5ms & не зависит & 0,0\$
SSD & XXX Gb & микросекунды & не зависит & 0,\$
ленты & большой\* & минуты & не зависит & ?  
\end{tabularx}
\* -- по сравнению с HDD

Классный сторян: RAM люди морозили в жидком азоте и если воткнуть ее в другой ноут, то данные оттуда еще можно достать. Таким образом люди перли пароль.
Ленты используются в облачном деле и используются для бэкапов.

Основная память для БД: RAM и HDD. Даже не SSD, потому что до сих пор, SSD имеет ограничение на количество циклов записи. У HDD вероятность деградирования ячеек памяти меньше.
Ожидаем, что размер данных существенно больше, чем размер оперативной памяти.

Тут рассказывают про примерное представление о жестком диске.
TODO: хоть бы картинку

Диск медленней оперативной памяти примерно в $10^4-10^5$ раз и хранит основные данные.

## Multiway merge sort

TODO картинку

M -- размер буфера в страницах
B(R) -- число страниц в отношении R(сколько страниц занимает та или иная таблица)
B(R) > M
Пусть мы захотели отсортировать таблицу представленную в нескольких страницах.
Почему мы не хотим QuickSort? Потому что он хоть и быстрый, но при своих действиях меняет числа в массиве на разных позициях. А эти числа могут находится в разных страницах. Это не то же самое, что просто $n log n$ сравнений памяти.

I фаза. Частичная сортировка

\begin{lstlisting}
k := $[@B(R)/M@]$ + 1
for i in 1..k: // читаем блоки отношения k раз
	буфер := M // блоков $\subset R$ с диска
	sort( буфер ) // любая удобная сортировка
	$R_i \over{output} {:=} $ буфер // отсортированный список
\end{lstlisting}

II фаза. Слияние. 
Обычный merge: берем два списка и мержим их.
Multiway: то же самое, но k списков. To be continued...

Пример. Размер буфера М = 10 блоков, списка R = 150 блоков. Какое количество I/O для сортировки?
Считывавем 10 блоков в буфер и в отсортированный список 10 блоков -- 15 раз.

15 отсортированных списков
можем слить в один список только 10 из них.
100 блоков и 50 блоков

итого: $150 + 150 + 150 + 150 + 150 * 2$