# Лекция 6

## Физическое выполнение запросов

Во время работы БД данные записываются в разные типы памяти. Поговорим про эти типы.

\begin{tabularx}{\textwidth}{c | c | c | c | c}
Тип памяти & Объем & скорость доступа & энергозависимость & цена/Gb
Cache процессоры & XX Mb & 1ns & зависит & \$\$\$
RAM & XXX Gb & 100ns & зависит & \$\$
HDD & X Tb & 1-5ms & не зависит & 0,0\$
SSD & XXX Gb & микросекунды & не зависит & 0,\$
ленты & большой\* & минуты & не зависит & ?  
\end{tabularx}
\* -- по сравнению с HDD

Классный сторян: RAM люди морозили в жидком азоте и если воткнуть ее в другой ноут, то данные оттуда еще можно достать. Таким образом люди перли пароль.
Ленты используются в облачном деле и используются для бэкапов.

Основная память для БД: RAM и HDD. Даже не SSD, потому что до сих пор, SSD имеет ограничение на количество циклов записи. У HDD вероятность деградирования ячеек памяти меньше.
Ожидаем, что размер данных существенно больше, чем размер оперативной памяти.

Тут рассказывают про примерное представление о жестком диске.
\includegraphics[scale=0.5]{images/hdd.png}
Диск медленней оперативной памяти примерно в $10^4-10^5$ раз и хранит основные данные.

## Multiway merge sort

\begin{center}
\includegraphics[scale=0.8]{images/mms.png}
\end{center}

Дисковая страница(несколько последовательных секторов) -- единица ввода/вывода
M -- размер буфера в страницах
B(R) -- число страниц в отношении R(сколько страниц занимает та или иная таблица)
B(R) > M
Пусть мы захотели отсортировать таблицу представленную в нескольких страницах.
Почему мы не хотим QuickSort? Потому что он хоть и быстрый, но при своих действиях меняет числа в массиве на разных позициях. А эти числа могут находится в разных страницах. Это не то же самое, что просто $n * log(n)$ сравнений памяти.

I фаза. Частичная сортировка

\begin{lstlisting}
k := $[@B(R)/M@]$ + 1
for i in 1..k: // читаем блоки отношения k раз
	буфер := M // блоков $\subset R$ с диска
	sort( буфер ) // любая удобная сортировка
	$R_i \over{output} {:=} $ буфер // отсортированный список
\end{lstlisting}

II фаза. Слияние. 
Обычный merge: берем два списка и мержим их.
Multiway: то же самое, но k списков.
Реализация не слишком важна, но технически происходит следующее. Мы отсортировали какие-то блоки. Считываем в буфер первые страницы этих блоков и выбираем минимум. Минимум записываем в какую-то страницу. Когда на этой странице закончилось месте -- сбрасываем на диск. Повторяем процесс пока не запишем все данные.

Если $k < M => B(R) < M^2$
В первой фазе происходит 1 чтение и 1 запись каждой страницы. Т.е. 2B(R) операций.
Во второй фазе 1 чтение из $R_i$ и 1 запись в $output$. Также 2B(R) операций.
Всего получается 4B(R) операций.
Если M = 1Gb, то $M^2$ -- довольно большое пространство.
Как видно, сортировка это операция дорогая, поэтому использовать ее нужно с умом.

Пример. Размер буфера М = 10 блоков, списка R = 150 блоков. Какое количество I/O для сортировки?
Считывавем 10 блоков в буфер и в отсортированный список 10 блоков -- 15 раз.

15 отсортированных списков
можем слить в один список только 10 из них.
100 блоков и 50 блоков

итого: $150 + 150 + 150 + 150 + 150 * 2$