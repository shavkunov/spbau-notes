# Лекция 7

Работа с блоками

## Хранение отношений на диске

Одна страница это 8кб.
TODO: image
Как строка располагается в блоке.
Если строка состояла бы из чисел, мы бы записывали подряд.
Если мы хотим найти кортеж с номером n, то нужно получить смещение: $n * len($кортеж$)$
Но пусть у нас кортеж у нас не фиксированной длины. Тогда как?

Делают таблицу ссылок. Для каждого индекса кортежа указывается область памяти, где он находится.
Чтобы круче организовать память, ссылки размещаются в начале, а сами в кортеже в конце прямоугольникка.

Дальше мы фигачим связный список уже созданных страниц. 
Вообще без технических подробностей, как у нас организован указатель дисковых страниц.
Поэтому таким образом, таблица отношения R разбивается на страницы.

На диске обычно хранится большой файл и СУБД читает/пишет страницы файлы.
Адрес страницы: имя файла + смещение
Есть и второй вариант(архаичный?): СУБД управляет диском сама.
Адрес страницы(длинная телега): \#диска \#поверхности \#дорожки \#сектора

Отображение логического адреса в физический.
страница \#42: диск1 поверхность2 дорожка8 сектор256
		 \#43: ...

Логический указатель проходит по этим номерам страниц, из него получается физический указатель, и это уже отдается тому, кому нужно.

### Колоночное хранение.

Запрос: SELECT 1, SUM(3) FROM R GROUP BY 1.

Храним атрибуты по колонкам.

\begin{itemize}
\item[\textbf{+}:] быстрее запросы, выбираются мало столбцов
\item[\textbf{+}:] добавление и удаление колонок -- быстро
\item[\textbf{+}:] "бесконечное" кол-во колонок
\item[\textbf{---}:] сложнее выбрать все
\item[\textbf{---}:] дороже и сложнее запись
\end{itemize}

Это довольно популярный способ хранения данных в современных СУБД.
Чтение/запись небольшого кол-ва объектов(ограничение на странице пользователя)
Читаются мало объектов, но много свойств.
OLTP - online transaction processing
Читаются много объектов, мало атрибутов, нет операции записей(обычно редко)
OLAP - online analitics processing
online означает, что получаем ответ сразу.
Далее мы будем говорить про построчное хранение.
## Буфер и его страницы

TODO image

buffer -- место в оперативной память для дисковой страницы.
TODO : graph
При считывании комплюктер задатся вопросом: нужна страница? да: в буфере пуле есть место? да: прочесть с диска в буфер.
В буфере есть место? Нет. Хотим найти жертву и заместить жертву нужной страницей.
Есть несколько стратегий по нахождению жертвы.

### Стратегии замещения(поиск жертвы)

\begin{itemize}
\item любую, т.е. случайную
\item FIFO: первая в очереди.
\item LRU - least recently used: та, к которой доступ был очень давно
\end{itemize}
Пользуемся последней.

### Clock replacement(часовой алгоритм)

Организовали страницы на диске по кругу как часики на циферблаты.
Есть некоторая стрелка, которая вращается по часовой стрелке. У каждой страницы есть счетчик -- количество обращений к ней. Двигаясь по кругу, стрелка ищет жертву по счетчикам. Если счетсчик равен нулю, то эта страница нашла жертву. Если счетчик не ноль, то пока живи, но счетчик присваивается 0.
Счетчик становится 1, когда страницу читают или записывают.
Это была бинарная версия. В небинарной-- счетчик ++ при записи/чтении и действия стрелки: счетчик--.

Атрибуты буферов.
pin - флаг блокировки для вытеснения
устанавливается/снимаются обработчиком запросов.
dirty - флаг наличия записей: нужно ли синхронизировать буфер с диском.

Наличие этого флага говорит: 
\begin{itemize}
\item чтение может вызвать запись с диском
\item Существует страница, запись на которую произведена, но изменения на диск еще не применились.
\end{itemize}