# Лекция 7

Работа с блоками

## Хранение отношений на диске

Одна страница это примерно 8кб. Как строка располагается в блоке?
Если строка состояла бы из чисел, мы бы записывали подряд.
Если мы хотим найти кортеж с номером n, то нужно получить смещение: $n * len($кортеж$)$
Но пусть у нас кортеж у нас не фиксированной длины. Тогда как?

Делают таблицу ссылок. Для каждого индекса кортежа указывается область памяти, где он находится. Т.е. это указатель на память. Чтобы круче организовать память, ссылки размещаются в начале, а сами в кортеже в конце прямоугольникка.
\begin{center}
\includegraphics[scale=0.8]{images/memrelations.png}
\end{center}

Дальше мы фигачим связный список уже созданных страниц. 
Вообще без технических подробностей, как у нас организован указатель дисковых страниц.
Поэтому таким образом, таблица отношения R разбивается на страницы.
\begin{center}
\includegraphics[scale=0.8]{images/memtable.png}
\end{center}

На диске обычно хранится большой файл и СУБД читает/пишет страницы файла.
Адрес страницы: имя файла + смещение
Есть и второй вариант(архаичный?): СУБД управляет диском сама.
Адрес страницы(длинная телега): \#диска \#поверхности \#дорожки \#сектора

Отображение логического адреса в физический.
страница \#42: диск1 поверхность2 дорожка8 сектор256
		 \#43: ...

Логический указатель проходит по этим номерам страниц, из него получается физический указатель, и это уже отдается тому, кому нужно.

### Колоночное хранение.

Запрос: SELECT 1, SUM(3) FROM R GROUP BY 1.

Храним атрибуты по колонкам.

\begin{itemize}
\item[\textbf{+}:] быстрее запросы, выбираются мало столбцов
\item[\textbf{+}:] добавление и удаление колонок -- быстро
\item[\textbf{+}:] "бесконечное" кол-во колонок
\item[\textbf{---}:] сложнее выбрать все
\item[\textbf{---}:] дороже и сложнее запись
\end{itemize}

Это довольно популярный способ хранения данных в современных СУБД. Чтение/запись небольшого кол-ва объектов(ограничение на странице пользователя). Читаются мало объектов, но много свойств. Это называется OLTP - online transaction processing.
Есть и другая аббревиатура. OLAP - online analitics processing. Читаются много объектов, мало атрибутов, нет операции записей(обычно редко)
online означает, что получаем ответ сразу.
Далее мы будем говорить про построчное хранение, для которого годится OLTP
## Буфер и его страницы

buffer -- место в оперативной памяти для дисковой страницы.
При считывании компьютер задатся вопросом: нужна страница? 
Если да: есть ли место в буфере? если да, то прочесть с диска в буфер.
Если в буфере нет места, то хотим найти жертву и заместить жертву нужной страницей.
Есть несколько стратегий по нахождению жертвы.

### Стратегии замещения(поиск жертвы)

\begin{itemize}
\item любую, т.е. случайную
\item FIFO: первая в очереди.
\item LRU - least recently used: та, к которой доступ был очень давно
\end{itemize}
Пользуемся последней.

### Clock replacement(часовой алгоритм)

\begin{center}
\includegraphics[scale=0.8]{images/clockreplacement.png}
\end{center}
Организовали страницы на диске по кругу как часики на циферблаты.
Есть некоторая стрелка, которая вращается по часовой стрелке. У каждой страницы есть счетчик -- количество обращений к ней. Двигаясь по кругу, стрелка ищет жертву по счетчикам. Если счетчик равен нулю, то эта страница нашла жертву. Если счетчик не ноль, то пока живи, но счетчик присваивается 0.
Счетчик становится 1, когда страницу читают или записывают.
Это была бинарная версия. В небинарной счетчик увеличивается на единицу при записи/чтении и действия стрелки уменьшают счетчик на единицу.

### Атрибуты буферов
pin - флаг блокировки для вытеснения. Устанавливается/снимаются обработчиком запросов.
dirty - флаг наличия записей: нужно ли синхронизировать буфер с диском.

Наличие этого флага говорит: 
\begin{itemize}
\item чтение может вызвать запись с диском
\item Существует страница, запись на которую произведена, но изменения на диск еще не применились.
\end{itemize}

Задача. Пусть у нас есть некоторое отношение R(id, value). 450 страниц и каталог(1 страница) с расположением остальных страниц, где располагается каталог мы знаем. У нас есть буфер размером 100 страниц. Буфер с LRU. Нет памяти кроме буфера. Выполняем запрос: SELECT value + 1 FROM R. Сколько раз мы прочитаем страницу каталога? Чтобы прочитать отношение, нужно сделать 5 порций чтения. И на каждой порции мы должны прочитать каталог. Чтение следующей страницы вытеснит каталог из буфера. Другой у нас ответ это 1, т.к. у нас нет памяти кроме буфера, то каталог не вытесняется из буфера по политике LRU.
