# Лекция 13

Разминка.
R(a, b) порядок
S(b, c) $R \bowtie S \bowtie T$
T(c, a)

\begin{tabular}{c c c c}
\_ & R & S & T 
T & 1000 & 5000 & 200 
$V_a$ & 1000 & \_ & 50
$V_b$ & 2500 & 5000 & \_
$V_c$ & \_ & 40 & 200
\end{tabular}

Т это размер таблицы, кардинальность оказалась больше таблицы, но пофиг

Какой самый лучший порядок? (минимизирующий пром. результаты) Всего у нас их три:
(RS)T 
(RT)S
(TS)R

Правильный второй вариант. У нас только один промежуточный результат. Нужно его минимизировать
$|R \bowtie S| = @1k * 5k / 5k@ = 1k$
$|S \bowtie T| = @5k * 200 / 200@ = 5k$
$|R \bowtie T| = @1k * 200 / 1k@ = 200$
RT и дальше соед. с S

Для 3 вариантов еще несложно, а что если побольше? Будем действовать жадным алгоритмом.
База пара с мин. ресурсом. То же самое для N - 1 отношения. Следующее отношение -- то, которое умеет минимизирует размер соединения с текущим результатом. Т.е: 
Индукция: $\under{i} min(R_i \bowtie (Result_{n - 1}))$

Рассмотрим это на примере.

\begin{tabular}{c c c c c}
\_ & R(a, b) & S(b, c, d) & T(c, e) & U(d, e)
T & 100 & 100 & 200 & 200
$V_a$ & 50 & \_ & \_ & \_
$V_b$ & 100 & 100 & \_ & \_
$V_c$ & \_ & 2 & 2 & \_
$V_d$ & \_ & 2 & \_ & 20
$V_e$ & \_ & 2 & 200 & 200
\end{tabular}

Предположения об атрибутах

1) Вложенность множества значений. (мы благодаря этому построили оценку размера соединения)
2) Сохранение множеств значений. Т.е. если $R(a, b) \bowtie S(b, c)$ и мы считаем кардинальность $V_a$:
$V_a(R(a, b) \bowtie S(b, c)) = V_a(R)$


Общая формула для соединения нескольких отношений:
$|R_1 \bowtie ... \bowtie R_n| = @T(R_1) \times ... \times T(R_n) / V_{a_i, 2} \times V_{a_i, 3} ...@ $
$a_i$ атрибуты входящие в больше чем одно отношение 
$V_{a_i, 1}$ -- наименьшая кардинальность
$V_{a_i, 1} \times V_{a_i, K_i}$ -- упорядоченные кардинальности общего атрибута $a_i$ для $K_i $ отношений

Вернемся к примеру и насчитаем кое-что:

|RS|: $@100 * 100 / 100@ = 100$
|RT|: $ 100 * 200 = 20k$
|RU|: $20k$
|ST|: $@ 100 * 200 / 2@ = 10k$
|SU|: $@ 100 * 200 / 20@ = 1k$
|TU|: $@ 200 * 200 / 200@ = 200$
|(RS)T|: $ @|RS| * |T| / 2@ = @100 * 200 / 2@ = 10k$
|(RS)U|: $ @|RS| * |U| / 20@ = @100 * 200 / 20@ = 1k$
Получили некоторое лево рекурсивное дерево (((R, S) U), T)
Общая стоимость 100 + 1000 = 1100.

Получили ли мы оптимальный(мин. пром. результаты) результат? Наверное оптимальным все же было бы дерево (R, S), (T, U)). Или, если мы рассматриваем только леворекурсивные деревья, то лучше было бы (((T, U) S), R). Придем к этому ответу с помощью другого алгоритма.

## Динамическое программирование

Будем строить таблицу, где будем запоминать: размер результата, его стоимость получения, оптимальная последовательность для получения.

\begin{tabular}{c c c}
\_ & Cost & Size 
RS & \_ & 100
RT & \_ & 20k
RU & 0 & 20k
ST & \_ & 10k
SU & \_ & 1k
TU & \_ & 200
\end{tabular}

\begin{tabular}{c c c}
\_ & Cost & Size 
(RS)T & 100 = min(|RS|, |ST|, |RT|) & 10k
R(TU) & 200 & $200 * 100 = 20k$
(RS)U & 100 & $@100 * 200 / 20@ = 1k$
S(TU) & 200 & $@200 * 100 / 2 * 20@ = 500$
\end{tabular}

Получили оптимальный план для каждой тройки, теперь для четверок:
Мы если что по прежнему рассматриваем только леворекурсивные деревья.

RSTU: считаем стоимости, размер должен у всех получиться одинаковым
(RST)U : 100 + 10k = 10100
(RTU)S : 200 + 20k = 20200
(RSU)T = 1100
(S(TU))R = 700

$(RS) \bowtie (TU)$ был бы оптимальнее, если бы мы рассматривали и другие деревья.
Динамика по отзывам(из postgres, где она делается по умолчанию) работает хорошо, где отношений в соеденении не более чем 10-15. Если больше, то используется жадный алгоритм например.

На этом все оптимизационные штуки мы закончили. 

# Транзакции(Барашев сильно улыбается). Конкурентный доступ к данным.

Если есть несколько ядер, то есть возможность параллельного выполнения
Диск медленнее(чтение еще идет асинхронно) чем CPU, поэтому пока крутится диск, можно нагружать CPU еще чем-то.
Наличие прогресса выполнения запроса для пользователя.

И так, мы хотим параллельно выполнять запросы. Но с таким подходом мы получаем также следующие проблемы:

Грязное(неподтвержденное) чтение. Если какой-то запрос начал обновлять таблицу и обновляет много строк. Второй запрос читает таблицу. Где-то он получил новые данные, где-то старые. Все плохо.
Потерянное обновление. Аналогично.

Что мы ожидаем от БД, которая заявляет, то, что она поддерживает транзакции?
Транзакция -- некоторая атомарная группа операций, переводящая из одного согласованного состояния в другое согласованное состояние. 
Под атомарностью понимается применение/неприменение сделанных изменений. Если изменения записываются, то записываются все изменения, если не записываются, то не записывается ничего.
Под согласованным состоянием понимается то состояние, где выполнены все ограничения. Какие? Такие же, которые сам программист и определил в БД: ключи, consraint и тп. Внутри самой транзации согласованность может нарушаться и это нормально. Т.е. если мы говорим о транзакции, традиционно мы вспоминаем перевод денег между считами. Условие: сумма на обоих счетах до и после транзакции должна совпадать. Из одной строчки мы отнимаем число. В другую строчку прибавляем это число. Между этими операциями согласованности нет.

## ACID-семантика транзакций.

Гарантии, которая дает БД при использовании транзакций.

A - Atomicity. Атомарность.
C - Consistency. Согласованность.
I - Isolation. Изолированность.
D - Durability. Долговечность.

Атомарность. То что было сделано в транзакции будут выполнено, либо ни одна из операций не будет выполнена. Т.е. изменения действительно атомарны.
Согласованность. БД проверит выполнения ограничений при фиксации транзакции. Фиксация транзакции -- успешное подтверждение выполнения.
Изолированность. С точки зрения программиста каждая транзакция выполняется так, как будто она в системе одна. Т.е. мы не заботимся о чтении/записи из других транзакций. Если бы мы писали на C++/Java, то привет всем Mutex и семафорам. БД берет на себя обязанность синхронизироваться между транзакциями. Это некоторая политика относительно разрешения конкурентных изменений.
Долговечность. Гарантия, что подтверждившиеся изменения не будут случайно утеряны. Под словом случайно понимается потеря без явных действий со стороны программы. Т.е. например выключили свет после подверждения транзакции. БД гарантирует, что изменения после восстановления питания будут.