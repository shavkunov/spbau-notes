# Лекция 12
TODO: картинки для планов
Разминка. $R(X, Y) \bowtie X(Y, Z)$
Y - ключ в S, внешний ключ в R
Что можно сказать про V(R, Y)?
Ответ: оно хотя бы 0 и не больше V(S, Y) = T(S)
по сравнению с кардинальностью других атрибутов.

# Оптимизации запросов 
Оптимизатор выбирает  лучший план
Например, запрос:
SELECT Z FROM R JOIN S WHERE R.x = C

Логический план:
$\Pi_Z -- \sigma_{R.x = C} -- \bowtie(R, S)$
(проекция по Z) -- выборка -- JOIN

Задача №1:
Применить преобразовния логического плана и получить более эффективный. Эффективный -- значит минимизирует/максимизирует целевую функцию. В нашем случае, она означает то, что мы хотим все сделать побыстрее. Иногда бывают и другие, например, уменьшить нагрузку.

Цель: время выполнения запроса -> min
Из чего время выполнения запроса складывается, если мы хотим его минимизировать?
Мы считаем, что самая жирная операция -- это работа с диском. Поэтому остальное мы игнорим(по крайней мере в этом курсе). Поэтому время пропорциональное количеству чтений/записей(I/O) с диска. Собственно, этой метрикой мы только и пользуемся.

Нарисуем эквивалентный план, где вместо соединения у нас стоит декартово произведение:
$\Pi_Z = \sigma_{R.x = C} = \times(R, S)$
Т.е. запрос был бы: SELECT Z FROM R WHERE R.x = C AND R.Y = S.Y

## Преобразования плана с помощью алгебраических операций
Для начала вспомним их:
Коммутативность: $R \bowtie S  = S \bowtie R$
Ассоциативность: $(R \cup S) \cup Z = R \cup (S \cup Z)$ -- объединение
или $(R \bowtie S) \bowtie T = R \bowtie (S \bowtie T)$
Дистрибутивность(селекции относительно декартова произведения): $\sigma_{R.x = C}(R \bowtie S) = \sigma_{R.x = C}(R) \bowtie S$. И аналогично относительно декартова произведения:
$\sigma_{R.x = C}(R \times S) = \sigma_{R.x = C}(R) \times S$
Нас будет интересовать дистрибутивность.

# Проталкивание предикатов(predicate push down)
Все операции, которые могут уменьшить размер отношений должны опуститься максимально глубоко. Т.е.
$\sigma_{\theta_1 AND \theta_2}(R) = \sigma_{\theta_1}(\sigma_{\theta_2}(R))$
Поэтому план который был выше упростится: $\Pi_z -- \bowtie(\sigma_{X = c} -- R, S)$
Можно еще немного упростить: если нам нужен только атрибут Z, то протолкнем его вниз тоже.

Кто-то может додуматься "помочь" оптимизатору:
\begin{lstlisting}
SELECT Z FROM S JOIN (
	SELECT \* FROM R WHERE x = c
) AS T;
\end{lstlisting}

В результате мы получаем менее читабельный запрос, но логический план оптимизатора остается тот же.

Хорошое быстрое выполения запроса лучше чем Отличное.
Потому что пока мы найдем отличный вариант выполнения запроса, пользователь состарится. Поэтому над некоторыми вещами оптимизатор не заморачивается. Т.е. мы не то чтобы ищем глобальный минимум, мы даже локальный минимум можем не искать.

Вернемся к нашему плану: 
$\Pi_z -- \bowtie(\sigma_{X = c} -- R, S)$
На месте $\bowtie$ могу быть вложенные циклы(NL), SJ, HashJoin, что выбрать?
На месте $\sigma_{X = c}$ может быть SeqScan или IndexScan.
Что нам поможет? Оптимизатор может использовать некоторую статистику(гистограммы и тп). Сбор стастистики если что тоже тратит время, что иногда тратит время работы, поэтому иногда администратор отключает это. 
\1 = @\text{размер результата}/\text{размер входа}@
Селективность выборки/запроса это $@1/\1@$
Применять индексы будем в случае, если селективность достаточно высока.
Выбор алгоритма соединения:
операнд слева(на дереве) < M ? Если да, то Nested Loops иначе используем HashJoin.

Немного модифицируем нашу цель. Заменим функцию стоимости: количество I/O заменяем на размер промежуточных отношений. Размер -- количество строк в отношении. Что же это такое? Чем больше строк в отношений, чем больше нужно I/O. То, что у нас стоит в листьях мы не можем влияет(это то что нам дали), на результат мы тоже не влияем. То что варьируется во время вычислений это количество промежуточных вычислений. 
Промежуточные результаты нужно записывать на диск, если они получаются большими(не помещаются в буфер). 
В оперативной памяти находятся буфер страниц и рабочая память: там где могут находится промежуточные результаты. Рабочая память для одного клиента это около 10 мегабайт вот ее как раз запросто может и не хватить при больших результатах.
Т.е. они будут сжирать память и тратить время записи на диск. 
Таким образом, мы заинтересованы в том, чтобы уменьшать размер промежуточных результатов.

Напоминание $|\sigma_{X = C}(R)| ~~ @T(R)/V(R.x)@$
Если константу C мы выбираем равновероятно, то матожидание размера выборки будет одинаковым.
$E = \sum \limits_C p_C * |\sigma_{X = C}(R)| = @1/n@ * \sum \limits_C |\sigma_{X = C}(R)| = @1/n@ * T(R)$, где n это V(R, x).
TODO: небольшой комментарий к этому
В реальности распределения значений скорее всего похожи на нормальные.
(пример гистограммы для роста)
Другой вариант: какая-нибудь вариация степенного распределения.
(пример гистограммы для размеры городов/клики на страницах)

"Сейчас будет черная магия, моя любимая"
## Размер соединений

Задача: найти размер соединения. 

Мы будем предполагать, что
1) Вложенность множеств значений атрибутов.
пусть у нас есть идентификаторы объектов.

Если $V(R, Y) <= V(S, Y)$, тогда $\Pi_Y(R) \subset \Pi_Y(S)$

$R(X, Y) \bowtie S(Y, Z)$
Пусть $V(R, Y) <= V(S, Y)$
$r \in R$ Сколько с ним соединятся? $s \in S$ : $@T(S)/V(S, Y)@$
$|R \bowtie S| = @T(R) * T(S)/V(S, Y)@$

Пусть $V(R, Y) >= V(S, Y)$. Для $s \in S$.
$@T(R)/V(R, Y)@$ пар.
Т.е. $|R \bowtie S| = @T(R) * T(S)/V(R, Y)@$

Т.е. в итоге: $|R \bowtie S| = @T(R) * T(S)/max(V(R, Y), V(S, Y))@$

Y -- ключ в S(Foreign Key в R) $|R \bowtie S| = @T(R) * T(S)/V(S, Y)@ = T(R) * 1$
$V(R, Y) = V(S, Y) = 1 => |R \bowtie S| = T(R) * T(S) = |R \times S|$

Y -- ключ в R и S, то $|R \bowtie S| = @T(R) * T(S)/max(T(R), T(S))@ = min(T(R) * T(S))$

# Порядок выполнеия соединений

SELECT FROM R JOIN S JOIN T JOIN U
WHERE ...

TODO: Картинки
Можем расставить скобки как нам только захочется. Соединение -- ассоц. и коммут.
Леворекурсивное дерево(рекурсия влево)