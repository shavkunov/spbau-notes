# Лекция 9. Индексные структуры

Эта структура обладает следующими свойствами:
\begin{itemize}
\item Вспомогательная структура
\item Персистентная: индексы хранятся на том же хранилище, где и сами таблица
\item Избыточная
\end{itemize}

Пример. Страница 1кб.
\begin{tabular}{c | c c}
id & $a_1$ & $a_v$
1  & ... & ...
... & ... & ...
1000 & ... & ...
\end{tabular}
B(R) = 100

### Поиск без вспомогательных структур
SELECT \* FROM R WHERE id=566
E[кол-во страниц при поиске по id] = 50
Бинарный поиск $log_2 [B(R)] = 7$ 

### Страница индексов

Заведем страницы индексов. Т.е. для каждого id указатель на страницу.
Индекс -- плотный(dense index), значит, он хранит все значения индексированных атрибутов.
8 байт на указатель(4 байта) и размер индекса(4 байта)
тогда нам понадобится 8 страниц, 125 пар на страницу.

Полный просмотр индекса + чтение из $R = 9$ $I/O$
Бинарный поиск в индексе + чтение из $R = 4$ $I/O = log_2(8) + 1$

### Улучшенная страница индексов

В этом случае индекс -- разреженный(sparse index). 
Теперь для каждой страницы мы будем хранить первый номер ее атрибута.
Теперь нам нужна всего лишь одна страница на хранение этих индексов
2 I/O: индекс + чтение из R

Имеет смысл если R отсортированно.
В каком случае это будет менее эффективно, чем плотный индекс? В случае разреженного индекса все результаты будут занимать одинаковое кол-во I/O. Если мы будем спрашивать ключ, которого нет в БД, то в плотном индексе мы сразу прочитаем индекс и увидим что нет ключа с таким значением и ответ дадим сразу.

Следующий пример.
Предположим теперь то, что строки отношения R id не отсортированны. Построим плотный индекс. Сделаем еще один слой над индексами. Сделаем разреженный слой.

Это приводит нас к следующей идее:
## B-дерево(B-tree)
Мы будем говорить о модификации B+ дерева.

### Описание
Элементы: дисковые страницы. Пусть мы говорим об листах.
В произвольном узле храним n ключей и n + 1 указатель.
для каждого ключа свой указатель, последний указатель нужен для указания на соседа.
Отсортированный плотный ключ.

Теперь рассмотрим слой над листьями. Тут тоже n ключей со значениями из проиндексированного атрибута и n + 1 указатель. Пусть $K_i$ -- атрибут. Указатель слева от $K_i$ ведет на лист, т.ч. у него все ключи < $K_i$, $>= K_i - 1 $ если есть.

Теперь поговорим над общим слоем. Все тоже самое. Указатели ведут на соответствущее поддерево.
Пример дерева: TODO : картинка

Хотим, чтобы при вставке выполнялось:
1) Поменьше I/O
2) Сбалансированность
3) Заполненность узлов

В каждом узле листе хотим, чтобы было не менее $@n + 1/2@$ пар ключ значение
В каждом узле внутренним узле не менее $@n + 1/2@$ указателей.
n это максимальное количество ключей в узле.

### Поиск
Если N ключей во всем дереве, то стоимость поиска это $O(log_n(N))$

### Вставка

1) найти лист поиском
2) если в листе есть место $=>$ записали ответ и все.
3) если в листе нет места, тогда нужно расщеплять лист.
Первые $@n + 1/2@$ ключей остаются на прежнем месте, остальные уезжают на новую страницу. Отправляем наверх минимальное значение в этой странице: значение ключе и указатель на лист.
Пусть сверху во внутреннем узле есть место, то мы записываем указатель в нужное место и завершаем работу.
4) если места нет, то будет происходить деление внутреннего узла. $@n/2@$ ключей идут в левую часть, другая половина во вторую часть.

В худшем случае, мы будем расщеплять все узлы. Сложность будет также логарифмическая.

### Удаление

Находим индекса и ставим на него могильный камень. 

Пример. Таблица R. 10 млн строк. K = Primary key размером 4 байт. A = UNIQUE ключ размером 40 байт. Размер страницы 4к = 4000. Высота B-дерева для K и для A? Считаем, что указатель занимает 0 байт.
Решение. Если 4 байт то 1000 ключей на страницу, если 40, то 100. $\log_{1000}{10 млн}$ = 3. $\log_{100}{10 млн} = 4$.
