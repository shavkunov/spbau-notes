# Лекция 10

TODO картинка

Мы хотим от ключа хранить хеш функцию. В одной корзине хранятся некоторые ключи, указывающие на соответствующие строки отношения. Точнее, это хранится в некотором блоке. Если место в этом блоке закончилось, то мы добавляем еще один блок. Теперь два блока, которые содержат ключи у которых хеш функция совпадает.

K = количество ключей
h' = h mod K
Если число ключей растет, то нужно сделать пересчитать хеш таблицу.

## самый простой вариант

\begin{lstlisting}
K = K $ * $ 2
foreach(key, value) in hashtable:
	put(key, value) // кладем в какую-то в новую корзину.
\end{lstlisting}

Понятно, что это недешевая операция. Поэтому вопрос состоит в том, чтобы установить планку, по который мы начнем все пересчитывать. Мы хотим, чтобы был только один блок в какой-то корзине.
Идея: модифицировать стратегию поиска, рехешировать только часть таблицы.

## Extendible hashing(проще на вики наверн почитать)

$k = 2^i$ -- размер таблицы
будем брать последние i бит от h(k)

i = 2
Картинка: пример того, как бы могла выглядеть таблица. Перебрали последние два бита и в них храним соответствующие ключи. Определение блока, куда запихнем ключ: вычисление хеш функции, берем последние два бита. Попадаем в корзину. В корзине хранятся пары (key, value). Также, в каждой корзине записано дополнительно число. Это число помогает узнать, сколько значащих бит, чтобы мы реально учитываем. Т.е. это число, сколько последних бит совпадает у всех ключей(я так понял). Это число нужно для расщепления таблицы.

пример для i = 1.
У нас всего две ячейки. Попадаем в корзину, в зависимости конца ключа -- 0 или 1. Пусть мы вставили три ключа. 10100, 10000, 10001. Пусть у нас переполнился блок. 

Пример.
Вставка:
	1. найти корзину $k_j$,  в которую мы вставим.
	2. если место есть, то добавляем новое значение. иначе то может происходить разные варианты.
	Случай $k_j = i$ (количество значащих битов в странице равно количеству значащих битов в таблице).
	Тогда хеш таблицу надо растить.
	Если $k_j < i$. Стратегия: увеличить количество значащих бит в корзине и раскидать соответственно ключи.
Было 10100, 10000. В первой корзине. Пусть добавили 10110. Теперь картинка поменялась.
Добавим еще кое что и т.к. $k_j = i$, то таблицу надо увеличить.
Объясним это на примере, когда было i = 1.
Добавили значение в блок, блок переполнился и надо таблицу перестроить.
Появляется вдвое больше суффиксов. Каждый ключ идет в соответстующий блок. Также увеличиваем количество значащих бит в корзинах.

## Linear hashing

i - количество значащих бит в хеш-таблице.
k < $2^i$
в корзинах допускается > 1 блок
Но мы будем следить за тем, чтобы количество ключей, деленное на количество ячеек в таблице было меньше какой-то константы: $@r/k@ < C$. Т.е. ограничим среднее число ключей/корзину.
h' = h(ключ). Последние i bit. 
Если h' -- целое число = m
если $m < k => $ m -- номер ячейки/корзины для поиска
если $m > k =>  m' = 2^i - m$

Вставка:
	Если $@r/k@ < C$, то все ок: добавляем просто в блок ключ.
	При переполнении блока добавим новый блок.

	Если $@r/k@ > C => $ добавляем ячейку.
	перемещаем из ячейки w ключи в 1w

Если после добавляение ячейки $k = 2^i => $ i = i + 1. После этого, у нас появляется новые неиспользуемые поля.
В случае Extendible hashing места в памяти может не хватить, при перестроении таблицы в два раз. В Linear hashing мы можем добавить произвольное количество ячеек в конец. Что делает этот способ более гибким в этом смысле.

Когда нам важен порядок -- тогда хеш таблицы использовать не нужно. B-дерево про порядок знает и запрос связанный с порядком выполнит лучше.
