# Лекция 14

Разминка.
TODO -- сорян, опоздал.

## Расписание
последовательность действий транзакций.

Два вида расписаний:
Последовательное(serial) с расписанием: действия разных транзакций не перемешиваются.
Далее шел просто пример с двумя транзакциями. Операции которых, если бы перемешались была бы каша.
TODO

Сериализуемое(serializable) расписание транзакций $T_1, ... T_n$:
эффект его == эффекту некоторого последовательного расписания
Под эффектом подразумеваем состояние БД.

Рассмотрим пример расписаний:

\begin{lstlisting}
$T_1$:
READ(A)
A += 100
WRITE(A)

$T_2$:
READ(A)
A \*= 2
WRITE(A)

$T_1$:
READ(B)
B += 100
WRITE(B)

$T_2$:
READ(B)
B \*= 2
WRITE(B)
\end{lstlisting}

$T_1$, $T_2$ эквивалентное последовательное расписание, значит, расписание дает такой же результат, если бы оно выполнилось ровно так как написали. $T_2$, $T_1$ -- даст другой результат. Это расписанием сериализуемое. Пример посложнее:

\begin{lstlisting}
$T_1$:
READ(A)
A += D
WRITE(A)

$T_2$:
READ(A)
A *= C
WRITE(A)

$T_2$:
READ(B)
B += C
WRITE(B)

$T_1$:
READ(B)
B += D
WRITE(B)
\end{lstlisting}

Будет ли оно сериализуемом. D = 0 и C = 1, то нам все равно в каком порядке выполнять. Если D, C -- случайные значения, то это расписание несериализуемое. Довольно кэпский вывод, что результат транзакции зависит от того, что в ней происходит. Предположим, что у нас нет действий программиста, остались только READ и WRITE. Сейчас нам станет жить легче.
$R_i(X) W_i(X)$
X -- объект, над которым производится действия, i -- номер транзакции. R, W -- тип действия(Read, Write). 
Перепишем пример в этой нотации:
$R_1(A) W_1(A) R_2(A) W_2(A) R_2(B) W_2(B) R_1(B) W_1(B)$

Рассмотрим понятие конфликта действий. Два действия конфликтуют, если результат расписания зависит от их порядка.
Какие действия очевидно не конфликтуют? Два чтения. В любом случае данные нужно прочитать, поэтому от их порядка ничего не зависит.
Нарисуем матрицу действий.

\begin{tabular}{c c c c c}
\_     & $R_2(X)$ & $R_2(Y)$ & $W_2(X)$ & $W_2(Y)$
$R_1(X)$ &  +    &   +   &  -    &  +
$R_1(Y)$ &  +    &   +   &  +    &  -
$W_1(X)$ &  -    &   +   &  -    &  +
$W_1(Y)$ &  +    &   -   &  +    &  -
\end{tabular}

Если читается и записивается одно и то же -- то конфликт. Если оперируем с разными переменными -- то нет(см. клетку 1 ряд 4 столбец и 4 ряд 1 столбец)
Из матрицы можем сделать вывод: если действия оперируют с одним и тем же объектом и хотя бы одна из них это запись(W), то переставить их местами мы не можем.
Что мы понимаем под объектом? Таблицу лучше не надо. С большинстве СУБД считается, что это строка.

Сериализуемость по конфликтам. Если расписание привести к последовательному перестановками рядом стоящих неконфликтных действий.(TODO пояснить немного)
Является ли пример, который был выше сериализуемым по конфликтам? Нет, поскольку есть конфликты которые мешают это сделать: $W_1(A)R_2(A)$ и $W_2(B)R_1(B)$.

## Тест на сериализуемость по конфликтам
Орграф предшествования для расписания $S = T_1...T_n$. Вершины -- транзакции. 
Ребро $T_i$, $T_j$, если в S есть конфликтующие действия транзакции $T_i$, $T_j$ и действие $T_i$ стоит перед действием $T_j$.

Если граф ацикличен, то расписание сериализуемо по конфликтам. И его можно получить топологической сортировкой.
Теорема. Расписание S сериализ. по конфликтам $ <=> $ в графе предшествования для соответствующего расписания нет циклов.
Если в графе есть циклы, то по определению.
В расписании: $T_1...T_2...T_3...T_1$ -- конфликт действий. По определению сериализуемости -- ее мы не получаем.
Если в графе нет циклов. Существует вершина без входящих ребер($T_k$). $ => $ действия $T_k$ можно переставить в начало расписания(иначе в $T_k$ было бы входящее ребро). Таким образом, можем запуститься "рекурсивно" от того, что осталось справа. Или иначе говоря, мы провели индукцию. После того как переставили $T_k$ в начало, удалили ее из графа.
## Блокировки
Планировщик на блокировках.

$R_1(X)W_2(X)$ -- неповторяемое чтение
$W_2(X)R_1(X)$ -- грязное чтение
$W_1(X)W_2(X)$ -- потерянное обновление

На действие мы можем повесить "замочек"(mutex). Если бы каждая транзакция вешала бы mutex на каждый элемент, которая она хотела бы прочитать, то конфликты бы разрешались. 

Правила(бойцовского клуба) блокировок
1. Хочешь что-то сделать с X -- ставь mutex на него
2. Повесил mutex -- не забудь снять(после действия)
3. Двух mutex-ов на одном объекте быть не может

Таким образом появились два новых действия: $L_i(X)$ -- блокировка X i-ой транзакцией, $U_i(X)$ -- разблокировка.
Эти правила можно и сформулировать с этими новыми действиями.

Если мы хотим что-то сделать с Х и на нем висит mutex -- то, ждем пока его снимут.
4. Все блокировки, сделанные транзакцией i предшествуют всем ее разблокировкам.
TODO график количества блокировок в зависимости от времени.
Он будет выглядеть как ступенчатый график.

Двухфазный протокол блокировок aka 2PL - two-phase locking.
Когда транзакция завершается, то блокировки все снимаются.
Поэтому у нас в конце получился обрыв. Обрыв лучше чем ступеньки, потому что есть возможность другой транзакции получить mutex и тогда будет плохой.

Теорема. Расписание,  построенное с помощью с 2PL сериализуемо по конфликтам.
по индукции. База. Расписание одной транзакции сериализуемо.
Пусть у нас есть расписание из n транзакций.
Найдем транзакцию, которая первой выполняет операцию снятие блокировки. Пусть i ее номер.
Проверим, что можно получить расписание $T_i$ S', где S' все транзакции кроме $T_i$.
Я прослушал...здесь от противного...

Усложнение блокировок: разделяющие(shared), экслюзивные(exlusive)
Таблица совместимости:?????
\begin{tabular}{c c c}
\_ & S & X
S  & + & -
X  & - & -
\end{tabular}

## Планировщик с временными ветками(timestamp ordering scheduler)

timestamp -- монотонная возрастающая последовательность целых чисел
Системные часы(иногда дают сбой)
Генератор значений

Каждой транзакции Т
дается TS(T) -- логическое время ее поступления

Модель мира:
	транзакции выполняеются мгновенно в момент поступления

В реальности:
	если расписание соответствует модели, то все ок
	если расписание невозможно в модели, то злимся...

У каждого объекта X есть два timestamp и один бит информации. Т.е.
RT(X) -- логическое время последнего чтения
WT(X) -- логическое время последней записи
C(X) -- подтверждение записи

Две невозможные ситуации с точки зрения планировщика.
Опоздавшая запись картинка
Опоздавшее чтение картинка

$R_i(X)$
1) $WT(X) <= TS(T_i) => если C(X)$, то ок
						$RT(X) = max(TS(T_i), RT(X))$
					 если $!C(X) =>$ подожди

2) $WT(X) > TS(T_i) => ROLLBACK T_i$ -- опоздавшее чтение

$W_i(X)$
1) $RT(X) > TS(T) => ROLLBACK T_i$ -- опоздавшая запись
2) $RT(X) < TS(T_i), WT(X) > TS(T_i)$
картинка: что делать?

$С(Х) => $ ничего
$!C(X) => $ либо подождать $T_i$ либо отложить запись $W_i(X)$

3) $RT(X) < TS(T_i)$
$WT(X)$ 
$WT(X) := TS(T_i)$
$C(X) := False$

## Многоверсионный протокол

1) У каждого объекта много версий
2) Каждая запись создает новую версию $X_t$
	$W_i(X)$ транзакций с $TS(T_i) = t$
3) При $R_i(X)$ читается $X_i: t < TS(T_i)$ не существует $X_t: t'>t$, $t'<TS(T_i)$
4) 
