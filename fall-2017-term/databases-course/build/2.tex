\section*{Водяная лекция 2
}

\subsection*{Реляционная модель
}

\noindent В ООП есть свои кирпичики — классы. \\
\noindent В реляционной модели это таблицы или отношения. \\

\noindent Основной элемент: отношение(relation) \\

\noindent Домен := некоторое множество значений(бесконечное или конечное) \\
\indent:= тип данных + некоторые ограничения на этот тип
\\
\noindent В домене определены некоторые операции. Сравнение, + * - / \\

\noindent Примеры доменов: BOOL, INT, TEXT, INT > 0 и так далее. \\


\noindent Рассмотрим следующую функцию:  \\
\noindent $f: D_1 \times
 … \times
 D_n -> true, false$ \\
\noindent $D_i$ — домен \\
\noindent $\{D_i\}_{i = 1}^n$ \\

\noindent $f$ — отношение на доменах $D_1, … D_n$. \\

\noindent Есть и другое определение: \\
\noindent Отношение: схема + тело. \\
\noindent Схема отношения — множество атрибутов. то есть $S = {(a_i, D_i)}$, $a_i$ — имя, $D_i$ — домен. Атрибут это пара. \\
\noindent $a_i == a_j$ => атрибуты равны. \\
\noindent Тело отношения — множество картежей. Кортеж $t = {(a_i, v_i)}$ $a_1, … a_n$ — последовательность имен атрибутов в $S$. \\
\noindent $v_i \in D_i$ \\

\noindent таблица№1 \\
\noindent Это графическое представление. \\

\noindent Можно также изобразить тоже самое в виде JSON: \\

\noindent \{ \\
\indent“a1”: 1,
\\\indent“a2”: true,
\\\indent“a3”: “abc”,
\\\indent“a4”: 3.14
\\\noindent \} \\

\noindent Если предикат f возращает истину, то строчка есть в таблице, иначе ее нет. \\
\noindent Одинаковые строчки мы запрещаем. \\

\noindent Равенство картежей \\
\noindent $t = t’$ если $V_{a_i}(t) = V_{a_i}(t’) \forall a_i \in S$ \\

\noindent Чего нет: \\
\noindent 1. Нет одинаковых кортежей(на практике всем пофиг) \\
\noindent 2. Нет упорядоченности кортежей \\
\noindent 3. Нет упорядоченности атрибутов \\
\noindent 4. В кортежах значений: атомарны \\

\noindent Аспекты модели данных \\

\noindent 1. Структура \\
\noindent 2. Операции \\
\noindent 3. Ограничения \\

\noindent Простейшие ограничения. \\
\noindent 1. Домен — ограничение множества значений \\
\noindent 2. Ограничения на атрибут внутри одной таблицы \\
\noindent 3. NULL или NOT NULL. \\


\noindent Потенциальный ключ. \\
\noindent Для некоторого отношения $R$ подмножство $K \subseteq
 S$ называется потенциальным ключом, если известно, что в любом экземпляре(конкретный набор строчек, то есть схема с конкретным телом) этого отношения \\
\noindent 1. Если в любом экземпляре $R$ для $t$ и $t’$ из $V_k(t) = V_k(t’) => t = t’$ \\
\noindent разных кортежей с одинаковым ключом не бывает \\
\noindent 2. (Неизбыточность) не существует $K’ 
 K$ для $K’$ выполняется 1. \\
\noindent Если выполняется только 1. то это суперключ. \\

\noindent Рассмотрим таблицу Студенты \\
\noindent направление | №паспорта | ФИО | №Студ | билета | №Группы \\

\noindent №паспорта и № студ. билета могут рассматриваться как потенциальный ключ. \\
\noindent По этим штукам можно однозначно определить студента. \\
\noindent Суперключ: например №паспорта + ФИО \\

\noindent Неизбыточность нужна, чтобы моделировать правила предметной области точно. не было студентов с совпадающими номерами паспортов \\

\noindent Потенциальный ключ (candidate key) \\
\noindent Первичный ключ(primary key) \\

\subsection*{Практика
}

\noindent stepik.org/lesson/54670 \\

\noindent И тут какие-то обычные SQL запросы. Я сижу на первом ряду и хоть немного что-то вижу, как люди на это смотрят вообще. \\
